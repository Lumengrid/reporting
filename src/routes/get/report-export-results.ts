import { NextFunction, Request, Response } from 'express';
import { ErrorsCode, GeneralErrorResponse } from '../../models/base';
import { BasePaginateResultResponse, ExportStatuses, ReportManagerInfo } from '../../models/report-manager';
import { ReportExtractionDetails, ReportExtractionInfo } from '../../services/dynamo';
import SessionManager from '../../services/session/session-manager.session';
import { SessionLoggerService } from '../../services/logger/session-logger.service';
import httpContext from 'express-http-context';
import { NotFoundException, DisabledReportTypeException } from '../../exceptions/';
import { DEFAULT_PAGE_SIZE } from '../../shared/constants';

/**
 * @category Report
 * @summary Get report results paginated
 * @method GET
 * @get report_id [string, required] ID of the report
 * @get export_id [string, required] Query execution id
 * @url /analytics/v1/reports/{report_id}/exports/{export_id}/results
 *
 * @parameter pageSize [integer, optional] Maximum number of results per page, min 1 and max 1000
 * @parameter page [integer, optional] The page number to return. The default value is 1. This parameter is optional. Available for datalake v3.
 * @parameter nextToken [string, optional] Token generated by the Athena service that specifies where to continue pagination. Not available for datalake v3.
 *
 * @response success [boolean, required] Whether or not the operation was successful
 * @response data [array(object), required] Array of results object
 * @response nextToken [string, required] A token generated by the Athena service that specifies where to continue pagination
 * @status 404 Not found
 * @end
 */
export const getReportExportResult = async (req: Request, res: Response, next: NextFunction) => {
    const session: SessionManager = res.locals.session;
    const dynamo = session.getDynamo();
    const logger: SessionLoggerService = httpContext.get('logger');
    let nextToken: string | undefined = req.query.nextToken ? req.query.nextToken.toString() : undefined;
    const pageSize: number | undefined = req.query.pageSize ? parseInt(req.query.pageSize.toString(), 10) : DEFAULT_PAGE_SIZE;
    const page: number | undefined = req.query.page ? parseInt(req.query.page.toString(), 10) : 1;

    const responseOptions: BasePaginateResultResponse = {success: true};

    let exportId = req.params.id_export;
    const reportId = req.params.id_report;

    res.type('application/json');

    let extraction: ReportExtractionInfo;

    // check if the file needs to be retrieved with access token
    try {
        const reportDetail = await dynamo.getReport(reportId) as ReportManagerInfo;
    } catch (e: any) {
        logger.errorWithStack(`Error on get report ${req.params.id_report} from dynamo - ${req.hostname}.`, e);
        if (e instanceof NotFoundException || e instanceof DisabledReportTypeException) {
            res.status(404);
            res.json(new GeneralErrorResponse('Report not found!', ErrorsCode.ReportNotExist));
        } else {
            res.sendStatus(500);
        }
        return;
    }

    // Check if the extraction was present
    try {
        extraction = await dynamo.getReportExtraction(reportId, exportId);
    } catch (error: any) {
        logger.errorWithStack('Error on recover report extraction', error);
        res.status(404);
        res.json(new GeneralErrorResponse('Extraction not found', ErrorsCode.ExtractionNotExist));
        return;
    }

    const info = new ReportExtractionDetails(extraction);

    // Return an error if the extraction wasn't completed
    if (info.status !== ExportStatuses.SUCCEEDED) {
        res.status(400);
        res.json(new GeneralErrorResponse('Extraction download not ready', ErrorsCode.ExtractionNotComplete));
        return;
    }

    // Return an error also if the extraction was older then 30 days (also the time was checked)
    if (info.getDaysElapsed() > 30) {
        res.type('application/json');
        res.status(404);
        res.json(new GeneralErrorResponse('Extraction download not found', ErrorsCode.ExtractionNotExist));
        return;
    }

    try {
        if (session.platform.isDatalakeV3ToggleActive()) {
            const snowflakeDriver = session.getSnowflake();
            responseOptions.data = await snowflakeDriver.getResultFromQueryIdPaginate(extraction.snowflakeRequestID, page, pageSize, extraction.snowflakeRequestSort);
            responseOptions.nextToken = '';
        } else {
            const athena = session.getAthena();

            // This is the case when a data refresh is needed before an export
            if (session.platform.isDatalakeV2Active() && info.queuedExtractionID) {
                exportId = info.queuedExtractionID;
            }

            // Workaround: The first result returned from Athena has also the header info.
            // To skip this object from the result we make two calls. The first one returns only the header info:
            // from the response we get the next token and make the second call that returns the actual results we want.
            // This happens only for the first page
            if (typeof nextToken === 'undefined') {
                const resultsHeaders = await athena.getQueryResult(exportId, 1, nextToken);
                nextToken = resultsHeaders.NextToken;
            }
            const results = await athena.getQueryResult(exportId, pageSize, nextToken);

            responseOptions.data = athena.getQueryResultsAsArray(results);
            responseOptions.nextToken = results.NextToken;
        }
        res.status(200);
    } catch (error: any) {
        logger.errorWithStack(`Error while getting report results (idReport: ${req.params.id_report}, exportId: ${req.params.export}).`, error);
        responseOptions.success = false;
        res.status(500);
        responseOptions.error = 'Generic error. See the logs for more information';
    }

    res.json(responseOptions);
};
